<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>一直往下划</title>
  <style>
    :root{
      /* First-paint fallbacks so content won't sit under fixed bars */
      --barH: 64px;   
      --scanH: 46px;  
      --noteH: 36px;  
    }

    html, body {
      margin: 0; height: 100%;
      overflow: hidden; /* manual scroll via transformed rail */
      -webkit-user-select: none; user-select: none;
      background: #fff;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Helvetica,Arial,sans-serif;
    }

    /* 顶部固定输入栏 */
    #input-container{
      position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
      background: #fff;
      padding: calc(8px + env(safe-area-inset-top)) 16px 8px 16px;
      border-bottom: 1px solid #eee;
      display: flex; gap: 8px; align-items: center;
    }
    #text-input{ flex: 1; font-size:16px; padding:8px 10px; }
    #submit-btn{ font-size:16px; padding:8px 28px; }

    /* 顶部下面的“继续扫码”固定按钮 */
    #scan-btn{
      position: fixed; left: 0; right: 0; z-index: 999;
      top: calc(var(--barH, 64px));
      padding: 10px 16px;
      background: #000; color: #fff;
      border: 0; border-bottom: 2px solid #eee;
      font-size: 20px; text-align: center;
    }

    /* “向下划手机”提示（固定在扫码按钮下面） */
    #swipe-hint{
      position: fixed; left: 0; right: 0; z-index: 998;
      top: calc(var(--barH, 64px) + var(--scanH, 46px));
      padding: 8px 16px;
      background: #fff;
      text-align: center;
      font-size: 16px; color: #444;
      border-bottom: 1px dashed #e5e5e5;
    }

    /* 我们自己管理的“视口” 和 “轨道” */
    #viewport{
      position: absolute; inset: 0;
      overflow: hidden; /* 禁用原生滚动 */
      /* 预留 顶栏+按钮+提示 的空间 */
      padding-top: calc(var(--barH, 64px) + var(--scanH, 46px) + var(--noteH, 36px));
      background: #fff;
    }
    #rail{
      position: absolute; top: 0; left: 0; right: 0;
      will-change: transform;
    }

    /* 文本容器（按需保留你的留白） */
    #text-container{
      margin-top: 250px;              /* ✅ 按你的要求保留 */
      padding: 16px 20px 180px;       /* 底部留白 */
      font-size: 20px; line-height: 1.7;
    }

    /* 摄像头画布覆盖层 */
    video#cam{ position:absolute; width:1px; height:1px; opacity:0; pointer-events:none;}
    canvas#camCanvas{
      position:fixed; inset:0; display:none; z-index:9999;
      width:100vw; height:100vh;
    }

    /* 扫码提示气泡 */
    .scanHint{
      position: fixed; left: 50%; bottom: 8vh; transform: translateX(-50%);
      background: rgba(0,0,0,.55); color: #fff;
      padding: 8px 12px; border-radius: 999px;
      font-size: 15px; z-index: 10000; display:none;
    }

    /* 可选：便携调试面板（需要时切换 display） */
    #debug{
      position: fixed; right: 8px; bottom: 8px; z-index: 10001;
      font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, monospace;
      background: rgba(0,0,0,.6); color:#fff; padding:8px 10px; border-radius:8px;
      display:none;
    }
  </style>
</head>
<body>
  <!-- 顶部输入栏 -->
  <div id="input-container">
    <input type="text" id="text-input" placeholder="扫码时你在想什么…">
    <button id="submit-btn">和我一起写</button>
  </div>

  <!-- 固定“继续扫码”按钮 -->
  <button id="scan-btn">继续扫码</button>

  <!-- 固定提示 -->
  <p id="swipe-hint">（在空白页面向上划手机屏幕）
    <br><br>若你也有添加你写的文字、或轻触屏幕修改段落，可截屏留念 <br>（此处不储存文字痕迹）
  </p>

  <!-- 手动滚动区域 -->
  <div id="viewport">
    <div id="rail">
      <div id="text-container"></div>
    </div>
  </div>

  <!-- 摄像头元素 -->
  <video id="cam" playsinline muted></video>
  <canvas id="camCanvas"></canvas>
  <div id="scan-hint" class="scanHint">对准二维码…</div>

  <!-- 调试（可开） -->
  <div id="debug"></div>

  <script>
  window.addEventListener("DOMContentLoaded", function () {
    const textContainer = document.getElementById("text-container");
    const inputContainer = document.getElementById("input-container");
    const textInput = document.getElementById("text-input");
    const submitBtn = document.getElementById("submit-btn");
    const viewport = document.getElementById("viewport");
    const rail = document.getElementById("rail");

    const cam = document.getElementById("cam");
    const camCanvas = document.getElementById("camCanvas");
    const ctx = camCanvas.getContext("2d");

    const scanBtn = document.getElementById("scan-btn");
    const scanHint = document.getElementById("scan-hint");
    const swipeHint = document.getElementById("swipe-hint");

    const debugBox = document.getElementById('debug');
    const SAFARI = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

    // ============== 文本内容 & 触发短语 ==============
    const text = `这是让我们一直写下去的页面，你不断往下划。我继续写，你继续划。我继续写，你继续划。你好，世界！
你从哪里来？你是怎么到这里来的？你怎么经过手机维修店的？你从哪条街来？你经过了什么？你上街做了什么？你要修手机吗？你看到了什么？你今天看到了什么？今天你看到了什么？
今天你扫码了吗？你扫码了吗？扫码了吗。

小时候玩过家家经常扮演超市收银员的角色。那大概是我第一次感受到“权力”的手感：手握扫码枪，举起手臂、转动腕骨，瞄准另一块积木上的虚拟条码，
“哔”————识别的声音，是机器确认我存在的声音。扫取了信息，留下痕迹。伸出手的“扫”让公共与私人之间交换。
那一刻，身体比意识更早获得了“扫”与“检视”的能力。信息被读取，数据被写入，世界在哔声中被交换。
如今城市里不少大小超市的收银员都被自助收银机器取代，这倒刚好圆了我儿时的梦，每一次自主扫描都让我欣喜地练习扫描、确认规范。
于是我们逐渐认识“授权”、“拥有”、“标注”、“打卡”。或是在更多机器眼、摄像头面前经过扫过。我们伸出手、举起手机，主动出示二维码。

手机必须修好。武器必须准备好。

QR二维码从1994年日本的汽车流水线开始使用，为了更快速方便读取、追踪、管理信息。QR二维码的年龄跟我一样大。
日常中的我们似乎也成了工厂流水线上检视员，每扫一次即是与周围机器硬件的每一次握手：确认信息、获取信任、留下数据。
扫码的手势从工厂延伸到门禁闸口、摊位交易、展览空间、边境口岸；街道旁、餐桌上、核酸亭前、医院病床前……
带着相似的屈腕、同样的抬臂和呼吸。

你刚刚又扫了几个码？你举起手臂、盯住屏幕、等待系统响应，时间暂停，你必须走进机器的时间里，被暂时吸入二维网格中，延迟行动。

手握扫码抢。
手握手机。手握摄像头。从扫到拍。
打开手机摄像头，瞄准，触发系统程序，跳转链接。

手握手机，用手机摄像头观看，扫代替看，扫码代替握手。
但是坏掉的摄像头也能拍摄吗？坏掉的摄像头也可以扫描吗？
坏了也未必想起来修。我们已经忘记如何维修、维系，还是仅仅在维持？原厂的还是替补训练的？
你准备或没有准备好，总也得进去。
手机带我们走近每一个本地，生成与本地设施的每一次交换：识别、定位、上传……
又或是你被吸引去买了一个新的机器，又能拍了，又能扫了。

扫！拍！截屏。截屏。拍！

扫码，是一种无声的签名，也是一种写作。
我们在划动与扫描之间不断书写——用手指、用屏幕、用眼神。每一次划动都是延续的笔划，每一次扫描都是新的换行。
你不断往下划，我继续写；你划过扫过的手指与我的书写的代码重叠。
划动是一种阅读，也是一种同步：你阅读的同时，我在生成；你扫过的同时，我在记录。
你看似在阅读，其实也在被写；看似在控制，其实也在被控制。

“你扫码了吗？”是日常问候。也是“在吗？”、“你还在系统里吗？”
扫码也是“签名”；扫码也是“明白”；扫码也是让机器相信。

继续握紧手中的机器！继续扫！拍！`;

    const words = Array.from(text);
    const triggerPhrases = [
      "扫码了吗","我们伸出手、举起手机，主动出示二维码。","带着相似的屈腕、同样的抬臂和呼吸。",
      "手握扫码抢。","打开手机摄像头，瞄准，触发系统程序，跳转链接。","又能拍了，又能扫了。",
      "截屏。拍！","其实也在被控制。","继续扫！拍！"
    ];
    const fired = new Set();
    const maxTriggerLen = triggerPhrases.reduce((m,s)=>Math.max(m, s.length), 0);
    let recent = "", index = 0;

    // ============== 视口高度/保留空间测量（兼容 iOS Safari） ==============
    function vpHeight(){
      return window.visualViewport ? Math.floor(window.visualViewport.height)
                                   : window.innerHeight;
    }
    function visibleHeight(){
      const cs   = getComputedStyle(document.documentElement);
      const hBar = parseFloat(cs.getPropertyValue('--barH'))  || inputContainer.getBoundingClientRect().height;
      const hScan= parseFloat(cs.getPropertyValue('--scanH')) || scanBtn.getBoundingClientRect().height;
      const hNote= parseFloat(cs.getPropertyValue('--noteH')) || swipeHint.getBoundingClientRect().height;
      return vpHeight() - hBar - hScan - hNote;
    }

    // 把最新文字保持在底部可见
    let offset = 0;
    function syncToBottom(){
      const visH = visibleHeight();
      const railH = rail.scrollHeight;
      const neededOffset = Math.max(0, railH - visH);
      if (neededOffset !== offset){
        offset = neededOffset;
        rail.style.transform = `translateY(${-offset}px)`;
      }
      // debugBox.style.display = 'block';
      debugBox.innerText =
        `vvh=${vpHeight()}  bar=${getComputedStyle(document.documentElement).getPropertyValue('--barH')}  scan=${getComputedStyle(document.documentElement).getPropertyValue('--scanH')}  note=${getComputedStyle(document.documentElement).getPropertyValue('--noteH')}\n`+
        `railH=${railH} visH=${visH} offset=${offset}`;
    }

    // 高度设置（防止首次布局压住内容）
    const setHeights = (() => {
      let raf = null;
      return function(){
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          const barH  = Math.ceil(inputContainer.getBoundingClientRect().height);
          const scanH = Math.ceil(scanBtn.getBoundingClientRect().height);
          const noteH = Math.ceil(swipeHint.getBoundingClientRect().height);
          document.documentElement.style.setProperty('--barH',  barH  + 'px');
          document.documentElement.style.setProperty('--scanH', scanH + 'px');
          document.documentElement.style.setProperty('--noteH', noteH + 'px');
          syncToBottom();
          raf = null;
        });
      };
    })();

    setHeights();
    window.addEventListener('load', setHeights);
    window.addEventListener('resize', setHeights);
    window.addEventListener('orientationchange', setHeights);
    if (window.visualViewport){
      visualViewport.addEventListener('resize', setHeights);
      visualViewport.addEventListener('scroll', setHeights);
    }
    if (document.fonts && document.fonts.ready){
      document.fonts.ready.then(setHeights).catch(()=>{});
    }
    new ResizeObserver(setHeights).observe(inputContainer);
    new ResizeObserver(setHeights).observe(scanBtn);
    new ResizeObserver(setHeights).observe(swipeHint);

    // ============== 追加文字 & 触发摄像头闪现 ==============
    function appendChar(ch){
      const span = document.createElement("span");
      span.textContent = ch + " ";
      span.addEventListener("click", function(){ this.style.display = "none"; });
      textContainer.appendChild(span);
      recent += ch;
      if (recent.length > maxTriggerLen) recent = recent.slice(-maxTriggerLen);
    }
    function checkTriggers(){
      for (const phrase of triggerPhrases){
        if (!fired.has(phrase) && recent.includes(phrase)){
          fired.add(phrase);
          startCameraForThreeSeconds();
          break;
        }
      }
    }

    // —— 首次 reveal 后强制修正（iOS Safari 迟滞绘制固定栏）——
    let firstRevealDone = false;
    function forceLayoutFix(){
      const barH  = Math.ceil(inputContainer.getBoundingClientRect().height);
      const scanH = Math.ceil(scanBtn.getBoundingClientRect().height);
      const noteH = Math.ceil(swipeHint.getBoundingClientRect().height);
      document.documentElement.style.setProperty('--barH',  barH  + 'px');
      document.documentElement.style.setProperty('--scanH', scanH + 'px');
      document.documentElement.style.setProperty('--noteH', noteH + 'px');
      syncToBottom();
    }

    const _revealN_core = function(n){
      for (let i=0; i<n; i++) {
        if (index >= words.length) break;
        appendChar(words[index++]);
      }
      checkTriggers();
      syncToBottom();
    };

    function revealN(n){
      _revealN_core(n);
      if (!firstRevealDone){
        firstRevealDone = true;
        if (SAFARI) setTimeout(forceLayoutFix, 20); // 让 Safari 完成第一次绘制后再纠偏
      }
    }

    // ============== 交互：上滑/滚轮按距离显示文字 ==============
    const PX_PER_CHAR_TOUCH = 28;
    const PX_PER_CHAR_WHEEL = 60;

    let touchStartY = 0, touchStartX = 0, accumulatedTouchPx = 0;
    const SWIPE_X_TOLERANCE = 80;

    function isInsideInput(el){ return inputContainer.contains(el); }

    document.addEventListener("touchstart", (e)=>{
      if (e.touches.length!==1) return;
      if (isInsideInput(e.target)) return;
      const t = e.touches[0];
      touchStartY = t.clientY; touchStartX = t.clientX; accumulatedTouchPx = 0;
    }, {passive:true});

    document.addEventListener("touchmove", (e)=>{
      if (e.touches.length!==1) return;
      if (isInsideInput(e.target)) return;
      const t = e.touches[0];
      const dy = touchStartY - t.clientY; // 上划为正
      const dx = Math.abs(t.clientX - touchStartX);
      if (dx > SWIPE_X_TOLERANCE) return;
      const newPx = dy - accumulatedTouchPx;
      if (newPx <= 0) return;
      const chars = Math.floor(newPx / PX_PER_CHAR_TOUCH);
      if (chars > 0) {
        revealN(chars);
        accumulatedTouchPx += chars * PX_PER_CHAR_TOUCH;
      }
    }, {passive:true});

    document.addEventListener("touchend", ()=>{ accumulatedTouchPx = 0; }, {passive:true});

    // 触发可视视口变化时也纠偏（Safari 地址栏伸缩）
    if (window.visualViewport){
      visualViewport.addEventListener('resize', forceLayoutFix);
      visualViewport.addEventListener('scroll', forceLayoutFix);
    }
    window.addEventListener('orientationchange', forceLayoutFix);

    // 触控板/鼠标滚轮：上滚显示
    let wheelAccum = 0;
    document.addEventListener("wheel", (e)=>{
      if (isInsideInput(e.target)) return;
      const upUnits = -e.deltaY; // 上滚为正
      wheelAccum += upUnits;
      const chars = Math.floor(Math.abs(wheelAccum) / PX_PER_CHAR_WHEEL);
      if (chars > 0){
        if (wheelAccum > 0) revealN(chars);
        wheelAccum = wheelAccum > 0
          ? wheelAccum - chars * PX_PER_CHAR_WHEEL
          : wheelAccum + chars * PX_PER_CHAR_WHEEL;
      }
    }, {passive:true});

    // ============== 摄像头 3 秒“扫”覆盖层 ==============
    function resizeCamCanvas(){
      camCanvas.width  = Math.floor(window.innerWidth * devicePixelRatio);
      camCanvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    resizeCamCanvas();
    window.addEventListener('resize', ()=>{ setHeights(); resizeCamCanvas(); syncToBottom(); });

    let streamRef = null, rafId = null, cameraActive = false, qrScanActive = false;

    async function startCameraForThreeSeconds(){
      if (cameraActive || qrScanActive) return;
      cameraActive = true;
      camCanvas.style.display = "block";
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        streamRef = stream; cam.srcObject = stream;
        await cam.play().catch(()=>{});
        const start = performance.now();
        const draw = (now)=>{
          drawVideoCover(); drawOverlayScan("扫");
          if (now - start < 3000){ rafId = requestAnimationFrame(draw); }
          else { stopCamera(); }
        };
        rafId = requestAnimationFrame(draw);
      } catch(err){
        console.warn("getUserMedia failed:", err);
        stopCamera();
      }
    }
    function drawVideoCover(){
      const cw = camCanvas.width / devicePixelRatio;
      const ch = camCanvas.height / devicePixelRatio;
      const vw = cam.videoWidth || cw;
      const vh = cam.videoHeight || ch;
      const scale = Math.max(cw / vw, ch / vh);
      const dw = vw * scale, dh = vh * scale;
      const dx = (cw - dw) / 2, dy = (ch - dh) / 2;
      const c = camCanvas.getContext('2d');
      c.clearRect(0,0,cw,ch);
      if (vw && vh) c.drawImage(cam, dx, dy, dw, dh);
    }
    function drawOverlayScan(text){
      const c = camCanvas.getContext('2d');
      const cw = camCanvas.width / devicePixelRatio;
      const ch = camCanvas.height / devicePixelRatio;
      c.save();
      c.fillStyle = "rgba(0,0,0,0.35)";
      c.fillRect(0,0,cw,ch);
      c.textAlign = "center";
      c.textBaseline = "middle";
      c.font = Math.round(Math.min(cw, ch) * 0.18) + "px sans-serif";
      c.fillStyle = "#fff";
      c.shadowColor = "rgba(0,0,0,0.5)";
      c.shadowBlur = 12;
      c.fillText(text, cw/2, ch/2);
      c.restore();
    }
    function stopCamera(){
      if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
      if (streamRef){
        streamRef.getTracks().forEach(t=>t.stop());
        cam.pause(); cam.srcObject = null; streamRef = null;
      }
      camCanvas.style.display = "none";
      cameraActive = false;
      qrScanActive = false;
      scanHint.style.display = "none";
    }

    // ============== 提交自定义文本（并保持底部可见） ==============
    submitBtn.addEventListener("click", ()=>{
      const userText = textInput.value.trim();
      if (!userText) return;
      userText.split(/\s+/).forEach(word=>{
        const w=document.createElement("span");
        w.textContent = word + " ";
        textContainer.appendChild(w);
        recent += word;
        if (recent.length > maxTriggerLen) recent = recent.slice(-maxTriggerLen);
      });
      checkTriggers();
      textInput.value = "";
      syncToBottom();
    });

    // ============== “继续扫码”按钮：相机 + BarcodeDetector ==============
    document.getElementById('scan-btn').addEventListener('click', startQrScan);

    async function startQrScan(){
      if (qrScanActive || cameraActive) return;
      if (!('BarcodeDetector' in window)) {
        alert('此浏览器暂不支持内置二维码识别（BarcodeDetector）。请使用最新版 Chrome/Edge/Android 浏览器，或在 iOS 17+ 的 Safari 中尝试。');
        return;
      }
      try {
        qrScanActive = true;
        camCanvas.style.display = "block";
        scanHint.style.display = "block";
        scanHint.textContent = "对准二维码…";

        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
        streamRef = stream; cam.srcObject = stream;
        await cam.play().catch(()=>{});

        const detector = new BarcodeDetector({ formats: ['qr_code'] });

        const tick = async ()=>{
          if (!qrScanActive) return;
          drawVideoCover(); drawOverlayScan("扫码中");
          try {
            const barcodes = await detector.detect(cam); // 直接在 <video> 上检测
            if (barcodes && barcodes.length) {
              const value = (barcodes[0].rawValue || '').trim();
              if (value) {
                stopCamera();
                const url = normalizeToUrl(value);
                if (url) window.location.href = url;
                else alert('扫描结果：' + value);
                return;
              }
            }
          } catch(e) {
            // 备选：在画布上再试一次
            try {
              const b2 = await detector.detect(camCanvas);
              if (b2 && b2.length) {
                const value = (b2[0].rawValue || '').trim();
                if (value) {
                  stopCamera();
                  const url = normalizeToUrl(value);
                  if (url) window.location.href = url;
                  else alert('扫描结果：' + value);
                  return;
                }
              }
            } catch(_) {}
          }
          rafId = requestAnimationFrame(tick);
        };
        rafId = requestAnimationFrame(tick);

        // 安全超时（20s 自动停止）
        setTimeout(()=>{ if (qrScanActive){ alert('未检测到二维码'); stopCamera(); } }, 20000);

      } catch (err) {
        console.warn('QR scan failed:', err);
        alert('无法打开摄像头：' + (err.message || err));
        stopCamera();
      }
    }

    function normalizeToUrl(value){
      try { return new URL(value).href; }
      catch(_){
        if (/^[\w.-]+\.[a-z]{2,}([/:?].*)?$/i.test(value)) return 'http://' + value;
        return null;
      }
    }

    // Safari layout nudge — no characters shown
    setTimeout(() => {
      window.dispatchEvent(new Event('resize'));
    }, 50);


  });
  </script>
</body>
</html>
